package com.missionhub.model;

import java.util.List;
import com.missionhub.model.DaoSession;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here
import com.google.common.collect.HashMultimap;
import com.google.common.collect.Multimaps;
import com.google.common.collect.SetMultimap;
import com.missionhub.model.gson.GEmailAddress;
import com.missionhub.model.gson.GPerson;
import com.missionhub.model.gson.GPhoneNumber;
import com.missionhub.util.TreeDataStructure;
import com.missionhub.util.U;
import com.missionhub.util.U.FollowupStatus;

import de.greenrobot.dao.QueryBuilder;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
// KEEP INCLUDES END
/**
 * Entity mapped to table PERSON.
 */
public class Person {

    private Long id;
    private String first_name;
    private String last_name;
    private String gender;
    private String campus;
    private String year_in_school;
    private String major;
    private String minor;
    private java.util.Date birth_date;
    private java.util.Date date_became_christian;
    private java.util.Date graduation_date;
    private String picture;
    private Long user_id;
    private Long fb_uid;
    private java.util.Date updated_at;
    private java.util.Date created_at;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient PersonDao myDao;

    private User user;
    private Long user__resolvedKey;

    private List<Address> addressList;
    private List<EmailAddress> emailAddressList;
    private List<PhoneNumber> phoneNumberList;
    private List<OrganizationalRole> organizationalRoleList;
    private List<ContactAssignment> assigned_to;
    private List<ContactAssignment> assigned_to_me;
    private List<FollowupComment> comments_on_me;
    private List<FollowupComment> followup_comments;
    private List<Rejoicable> rejoicableList;
    private List<AnswerSheet> answerSheetList;

    // KEEP FIELDS - put your custom fields here
 	/** system labels. */
 	private SetMultimap<Long, Long> mLabels; // organizationId, label
 	private TreeDataStructure<Long> mOrganizationHierarchy;
    // KEEP FIELDS END

    public Person() {
    }

    public Person(Long id) {
        this.id = id;
    }

    public Person(Long id, String first_name, String last_name, String gender, String campus, String year_in_school, String major, String minor, java.util.Date birth_date, java.util.Date date_became_christian, java.util.Date graduation_date, String picture, Long user_id, Long fb_uid, java.util.Date updated_at, java.util.Date created_at) {
        this.id = id;
        this.first_name = first_name;
        this.last_name = last_name;
        this.gender = gender;
        this.campus = campus;
        this.year_in_school = year_in_school;
        this.major = major;
        this.minor = minor;
        this.birth_date = birth_date;
        this.date_became_christian = date_became_christian;
        this.graduation_date = graduation_date;
        this.picture = picture;
        this.user_id = user_id;
        this.fb_uid = fb_uid;
        this.updated_at = updated_at;
        this.created_at = created_at;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getPersonDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getFirst_name() {
        return first_name;
    }

    public void setFirst_name(String first_name) {
        this.first_name = first_name;
    }

    public String getLast_name() {
        return last_name;
    }

    public void setLast_name(String last_name) {
        this.last_name = last_name;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public String getCampus() {
        return campus;
    }

    public void setCampus(String campus) {
        this.campus = campus;
    }

    public String getYear_in_school() {
        return year_in_school;
    }

    public void setYear_in_school(String year_in_school) {
        this.year_in_school = year_in_school;
    }

    public String getMajor() {
        return major;
    }

    public void setMajor(String major) {
        this.major = major;
    }

    public String getMinor() {
        return minor;
    }

    public void setMinor(String minor) {
        this.minor = minor;
    }

    public java.util.Date getBirth_date() {
        return birth_date;
    }

    public void setBirth_date(java.util.Date birth_date) {
        this.birth_date = birth_date;
    }

    public java.util.Date getDate_became_christian() {
        return date_became_christian;
    }

    public void setDate_became_christian(java.util.Date date_became_christian) {
        this.date_became_christian = date_became_christian;
    }

    public java.util.Date getGraduation_date() {
        return graduation_date;
    }

    public void setGraduation_date(java.util.Date graduation_date) {
        this.graduation_date = graduation_date;
    }

    public String getPicture() {
        return picture;
    }

    public void setPicture(String picture) {
        this.picture = picture;
    }

    public Long getUser_id() {
        return user_id;
    }

    public void setUser_id(Long user_id) {
        this.user_id = user_id;
    }

    public Long getFb_uid() {
        return fb_uid;
    }

    public void setFb_uid(Long fb_uid) {
        this.fb_uid = fb_uid;
    }

    public java.util.Date getUpdated_at() {
        return updated_at;
    }

    public void setUpdated_at(java.util.Date updated_at) {
        this.updated_at = updated_at;
    }

    public java.util.Date getCreated_at() {
        return created_at;
    }

    public void setCreated_at(java.util.Date created_at) {
        this.created_at = created_at;
    }

    /** To-one relationship, resolved on first access. */
    public User getUser() {
        if (user__resolvedKey == null || !user__resolvedKey.equals(user_id)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            UserDao targetDao = daoSession.getUserDao();
            user = targetDao.load(user_id);
            user__resolvedKey = user_id;
        }
        return user;
    }

    public void setUser(User user) {
        this.user = user;
        user_id = user == null ? null : user.getId();
        user__resolvedKey = user_id;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public synchronized List<Address> getAddressList() {
        if (addressList == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            AddressDao targetDao = daoSession.getAddressDao();
            addressList = targetDao._queryPerson_AddressList(id);
        }
        return addressList;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetAddressList() {
        addressList = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public synchronized List<EmailAddress> getEmailAddressList() {
        if (emailAddressList == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            EmailAddressDao targetDao = daoSession.getEmailAddressDao();
            emailAddressList = targetDao._queryPerson_EmailAddressList(id);
        }
        return emailAddressList;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetEmailAddressList() {
        emailAddressList = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public synchronized List<PhoneNumber> getPhoneNumberList() {
        if (phoneNumberList == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            PhoneNumberDao targetDao = daoSession.getPhoneNumberDao();
            phoneNumberList = targetDao._queryPerson_PhoneNumberList(id);
        }
        return phoneNumberList;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetPhoneNumberList() {
        phoneNumberList = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public synchronized List<OrganizationalRole> getOrganizationalRoleList() {
        if (organizationalRoleList == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            OrganizationalRoleDao targetDao = daoSession.getOrganizationalRoleDao();
            organizationalRoleList = targetDao._queryPerson_OrganizationalRoleList(id);
        }
        return organizationalRoleList;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetOrganizationalRoleList() {
        organizationalRoleList = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public synchronized List<ContactAssignment> getAssigned_to() {
        if (assigned_to == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            ContactAssignmentDao targetDao = daoSession.getContactAssignmentDao();
            assigned_to = targetDao._queryPerson_Assigned_to(id);
        }
        return assigned_to;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetAssigned_to() {
        assigned_to = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public synchronized List<ContactAssignment> getAssigned_to_me() {
        if (assigned_to_me == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            ContactAssignmentDao targetDao = daoSession.getContactAssignmentDao();
            assigned_to_me = targetDao._queryPerson_Assigned_to_me(id);
        }
        return assigned_to_me;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetAssigned_to_me() {
        assigned_to_me = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public synchronized List<FollowupComment> getComments_on_me() {
        if (comments_on_me == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            FollowupCommentDao targetDao = daoSession.getFollowupCommentDao();
            comments_on_me = targetDao._queryPerson_Comments_on_me(id);
        }
        return comments_on_me;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetComments_on_me() {
        comments_on_me = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public synchronized List<FollowupComment> getFollowup_comments() {
        if (followup_comments == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            FollowupCommentDao targetDao = daoSession.getFollowupCommentDao();
            followup_comments = targetDao._queryPerson_Followup_comments(id);
        }
        return followup_comments;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetFollowup_comments() {
        followup_comments = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public synchronized List<Rejoicable> getRejoicableList() {
        if (rejoicableList == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            RejoicableDao targetDao = daoSession.getRejoicableDao();
            rejoicableList = targetDao._queryPerson_RejoicableList(id);
        }
        return rejoicableList;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetRejoicableList() {
        rejoicableList = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public synchronized List<AnswerSheet> getAnswerSheetList() {
        if (answerSheetList == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            AnswerSheetDao targetDao = daoSession.getAnswerSheetDao();
            answerSheetList = targetDao._queryPerson_AnswerSheetList(id);
        }
        return answerSheetList;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetAnswerSheetList() {
        answerSheetList = null;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

    // KEEP METHODS - put your custom methods here
 	public SetMultimap<Long, Long> getLabelsCopy() {
 		if (mLabels == null) {
 			resetLabels();
 		}
 		return HashMultimap.create(getLabels());
 	}

 	private SetMultimap<Long, Long> getLabels() {
 		if (mLabels == null) {
 			resetLabels();
 		}
 		return mLabels;
 	}

 	public void resetLabels() {
 		final SetMultimap<Long, Long> labelsTemp = Multimaps.synchronizedSetMultimap(HashMultimap.<Long, Long> create());
 		resetOrganizationalRoleList();
 		try {
 			final List<OrganizationalRole> roles = getOrganizationalRoleList();
 			for (final OrganizationalRole role : roles) {
 				role.refresh();
 				labelsTemp.put(role.getOrganization_id(), role.getRole_id());
 			}
 		} catch (DaoException e) {
 			resetLabels();
 		}
 		mLabels = labelsTemp;
 	}

 	/**
 	 * Checks if a user has one of the given labels (role)
 	 * 
 	 * @param label
 	 * @param organizationId
 	 * @return true if they have the label
 	 */
 	public synchronized boolean hasLabel(final long organizationId, final long... label) {
 		boolean has = false;
 		for (final long l : label) {
 			if (getLabels().containsEntry(organizationId, l)) {
 				has = true;
 			}
 		}
 		return has;
 	}

 	/**
 	 * Checks if a user has all of the given labels (role)
 	 * 
 	 * @param label
 	 * @param organizationId
 	 * @return true if they have the label
 	 */
 	public synchronized boolean hasLabels(final long organizationId, final long ... label) {
 		boolean has = true;
 		for (final long l : label) {
 			if (!getLabels().containsEntry(organizationId, l)) {
 				has = false;
 			}
 		}
 		return has;
 	}

 	/**
 	 * Returns true if the user is an admin or leader in the given organizationId
 	 * 
 	 * @param organizationId
 	 * @return
 	 */
 	public synchronized boolean isAdminOrLeader(final long organizationId) {
 		return isAdmin(organizationId) || isLeader(organizationId);
 	}

 	/**
 	 * Returns true if the user is an admin in the given organizationId
 	 * 
 	 * @param organizationId
 	 * @return
 	 */
 	public synchronized boolean isAdmin(final long organizationId) {
 		return hasLabel(organizationId, U.Role.admin.id());
 	}

 	/**
 	 * Returns true if the user is a leader in the given organization
 	 * 
 	 * @param organizationId
 	 * @return
 	 */
 	public synchronized boolean isLeader(final long organizationId) {
 		return hasLabel(organizationId, U.Role.leader.id());
 	}
 	
 	/**
 	 * Returns the person's primary organization id
 	 * 
 	 * @return
 	 */
 	public Long getPrimaryOrganizationId() {
 		if (getUser() != null) {
 			return getUser().getPrimary_organization_id();
 		}
 		return -1l;
 	}

 	public Organization getPrimaryOrganization() {
 		if (daoSession == null) {
 			throw new DaoException("Entity is detached from DAO context");
 		}
 		final OrganizationDao targetDao = daoSession.getOrganizationDao();
 		return targetDao.load(getPrimaryOrganizationId());
 	}

 	public synchronized void resetOrganizationHierarchy() {
 		mOrganizationHierarchy = null;
 		getOrganizationHierarchy();
 	}
 	
 	/**
 	 * Returns a tree of the user's organizations
 	 * 
 	 * @return
 	 */
 	public synchronized TreeDataStructure<Long> getOrganizationHierarchy() {
 		if (mOrganizationHierarchy != null) {
 			return mOrganizationHierarchy;
 		}

 		if (daoSession == null) {
 			throw new DaoException("Entity is detached from DAO context");
 		}
 		final QueryBuilder<OrganizationalRole> builder = daoSession.getOrganizationalRoleDao().queryBuilder();
 		final List<Long> adminRoles = new ArrayList<Long>();
 		adminRoles.add(U.Role.admin.id());
 		adminRoles.add(U.Role.leader.id());
 		final List<OrganizationalRole> roles = builder.where(OrganizationalRoleDao.Properties.Person_id.eq(getId()), OrganizationalRoleDao.Properties.Role_id.in(adminRoles)).list();
 		
 		// build a tree from organization ancestry
 		final TreeDataStructure<Long> tree = new TreeDataStructure<Long>(0l);
 		
 		// store already add orgs
 		final Set<Long> organizations = new HashSet<Long>();

 		final Iterator<OrganizationalRole> roleItr = roles.iterator();
 		while (roleItr.hasNext()) {
 			final OrganizationalRole role = roleItr.next();
 			final Organization org = role.getOrganization();
 			if (organizations.contains(org.getId())) continue;
 			organizations.add(org.getId());
 			if (role.getOrganization().getAncestry() != null) {
 				TreeDataStructure<Long> parent = tree;
 				for (final String ancestor : role.getOrganization().getAncestry().trim().split("/")) {
 					final Long a = Long.parseLong(ancestor);
 					if (parent.getTree(a) == null) {
 						parent = parent.addLeaf(a);
 					} else {
 						parent = parent.getTree(a);
 					}
 				}
 				if (parent.getTree(org.getId()) == null) {
 					parent.addLeaf(org.getId());
 				}
 			} else {
 				tree.addLeaf(org.getId());
 			}
 		}

 		mOrganizationHierarchy = tree;
 		return mOrganizationHierarchy;
 	}
 	
 	/**
 	 * @return the person's full first and last name
 	 */
 	public String getName() {
 		String name = "";
 		if (!U.isNullEmpty(getFirst_name())) {
 			name += getFirst_name();
 		}
 		if (!U.isNullEmpty(getLast_name())) {
 			name += (" " + getLast_name());
 		}
 		return name.trim();
 	}
 	
 	public Address getCurrentAddress() {
 		for (Address address : getAddressList()) {
 			return address;
 		}
 		return null;
 	}
 	
 	public void deleteWithRelations() {
 		if (daoSession == null) {
 			throw new DaoException("Entity is detached from DAO context");
 		}
 		daoSession.getContactAssignmentDao().queryBuilder().whereOr(ContactAssignmentDao.Properties.Assigned_to_id.eq(id), ContactAssignmentDao.Properties.Person_id.eq(id)).buildDelete().executeDeleteWithoutDetachingEntities();
 		daoSession.getAddressDao().queryBuilder().where(AddressDao.Properties.Person_id.eq(id)).buildDelete().executeDeleteWithoutDetachingEntities();
 		daoSession.getEmailAddressDao().queryBuilder().where(EmailAddressDao.Properties.Person_id.eq(id)).buildDelete().executeDeleteWithoutDetachingEntities();
 		daoSession.getFollowupCommentDao().queryBuilder().whereOr(FollowupCommentDao.Properties.Contact_id.eq(id), FollowupCommentDao.Properties.Commenter_id.eq(id)).buildDelete().executeDeleteWithoutDetachingEntities();
 		daoSession.getOrganizationalRoleDao().queryBuilder().where(OrganizationalRoleDao.Properties.Person_id.eq(id)).buildDelete().executeDeleteWithoutDetachingEntities();
 		daoSession.getPhoneNumberDao().queryBuilder().where(PhoneNumberDao.Properties.Person_id.eq(id)).buildDelete().executeDeleteWithoutDetachingEntities();
 		daoSession.getRejoicableDao().queryBuilder().whereOr(RejoicableDao.Properties.Person_id.eq(id), RejoicableDao.Properties.Created_by_id.eq(id)).buildDelete().executeDeleteWithoutDetachingEntities();
 		daoSession.getUserDao().queryBuilder().where(UserDao.Properties.Person_id.eq(id)).buildDelete().executeDeleteWithoutDetachingEntities();
 		delete();
 	}
 	
 	public GPerson getGModel() {
 		final GPerson p = new GPerson();

		p.id = getId();
		p.first_name = getFirst_name();
		p.last_name = getLast_name();
		p.gender = getGender();

		final List<GEmailAddress> emails = new ArrayList<GEmailAddress>();
		final List<EmailAddress> addresses = getEmailAddressList();
		for (final EmailAddress address : addresses) {
			emails.add(GEmailAddress.createFromEmailAddress(address));
		}
		p.email_addresses = emails.toArray(new GEmailAddress[] {});

		final List<GPhoneNumber> numbers = new ArrayList<GPhoneNumber>();
		final List<PhoneNumber> phones = getPhoneNumberList();
		for (final PhoneNumber number : phones) {
			numbers.add(GPhoneNumber.createFromPhoneNumber(number));
		}
		p.phone_numbers = numbers.toArray(new GPhoneNumber[] {});

		final Address address = getCurrentAddress();
		if (address != null) {
			p.current_address = address.getGModel();
		}

		return p;
 	}
 	
 	public FollowupStatus getStatus(long organizationId) {
 		if (daoSession == null) {
 			throw new DaoException("Entity is detached from DAO context");
 		}
 		OrganizationalRole role = daoSession.getOrganizationalRoleDao().queryBuilder().where(OrganizationalRoleDao.Properties.Person_id.eq(getId()), OrganizationalRoleDao.Properties.Role_id.eq(U.Role.contact.id()), OrganizationalRoleDao.Properties.Organization_id.eq(organizationId)).unique();
 		if (role != null) {
 			return U.FollowupStatus.valueOf(role.getFollowup_status());
 		}
 		return null;
 	}
    // KEEP METHODS END

}
