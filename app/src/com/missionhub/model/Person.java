package com.missionhub.model;

import java.util.List;

import com.missionhub.model.DaoSession;

import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here
import android.view.View;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.Multimaps;
import com.google.common.collect.SetMultimap;
import com.google.i18n.phonenumbers.PhoneNumberUtil;
import com.google.i18n.phonenumbers.Phonenumber;
import com.missionhub.application.Application;
import com.missionhub.application.Session;
import com.missionhub.model.generic.FollowupStatus;
import com.missionhub.model.generic.Gender;
import com.missionhub.model.gson.GAddress;
import com.missionhub.model.gson.GEmailAddress;
import com.missionhub.model.gson.GPerson;
import com.missionhub.model.gson.GPhoneNumber;
import com.missionhub.util.IntentHelper;
import com.missionhub.util.PhoneUtils;
import com.missionhub.util.SimpleEntry;
import com.missionhub.util.TreeDataStructure;

import de.greenrobot.dao.AbstractDao;
import de.greenrobot.dao.query.WhereCondition;

import org.apache.commons.lang3.StringUtils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
// KEEP INCLUDES END

/**
 * Entity mapped to table PERSON.
 */
public class Person {

    private Long id;
    private String first_name;
    private String last_name;
    private String gender;
    private String campus;
    private String year_in_school;
    private String major;
    private String minor;
    private String birth_date;
    private String date_became_christian;
    private String graduation_date;
    private String picture;
    private Long user_id;
    private Long fb_uid;
    private String updated_at;
    private String created_at;
    /**
     * Used to resolve relations
     */
    private transient DaoSession daoSession;
    /**
     * Used for active entity operations.
     */
    private transient PersonDao myDao;
    private User user;
    private Long user__resolvedKey;
    private List<Address> addressList;
    private List<EmailAddress> emailAddressList;
    private List<PhoneNumber> phoneNumberList;
    private List<OrganizationalLabel> organizationalLabelList;
    private List<OrganizationalPermission> organizationalPermissionList;
    private List<ContactAssignment> assigned_to;
    private List<ContactAssignment> assigned_to_me;
    private List<Interaction> receivedInteractions;
    private List<Interaction> createdInteractions;
    private List<Interaction> updatedInteractions;
    private List<InteractionInitiator> interactionInitiatorList;
    private List<AnswerSheet> answerSheetList;
    // KEEP FIELDS - put your custom fields here
    private SetMultimap<Long, Long> mLabels; // organizationId, labelId
    private Map<Long, Long> mPermissions; // organizationId, permissionId
    private SetMultimap<Long, PermissionEntry> mPermissionCache;
    private TreeDataStructure<Long> mOrganizationHierarchy;
    private Map<Long, FollowupStatus> mStatuses;
    private EmailAddress mPrimaryEmailAddress;
    private PhoneNumber mPrimaryPhoneNumber;
    private Map<Long, ContactAssignment> mContactAssignments;
    private PersonViewCache mPersonViewCache;
    // KEEP FIELDS END

    public Person() {
    }

    public Person(Long id) {
        this.id = id;
    }

    public Person(Long id, String first_name, String last_name, String gender, String campus, String year_in_school, String major, String minor, String birth_date, String date_became_christian, String graduation_date, String picture, Long user_id, Long fb_uid, String updated_at, String created_at) {
        this.id = id;
        this.first_name = first_name;
        this.last_name = last_name;
        this.gender = gender;
        this.campus = campus;
        this.year_in_school = year_in_school;
        this.major = major;
        this.minor = minor;
        this.birth_date = birth_date;
        this.date_became_christian = date_became_christian;
        this.graduation_date = graduation_date;
        this.picture = picture;
        this.user_id = user_id;
        this.fb_uid = fb_uid;
        this.updated_at = updated_at;
        this.created_at = created_at;
    }

    /**
     * called by internal mechanisms, do not call yourself.
     */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getPersonDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getFirst_name() {
        return first_name;
    }

    public void setFirst_name(String first_name) {
        this.first_name = first_name;
    }

    public String getLast_name() {
        return last_name;
    }

    public void setLast_name(String last_name) {
        this.last_name = last_name;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public String getCampus() {
        return campus;
    }

    public void setCampus(String campus) {
        this.campus = campus;
    }

    public String getYear_in_school() {
        return year_in_school;
    }

    public void setYear_in_school(String year_in_school) {
        this.year_in_school = year_in_school;
    }

    public String getMajor() {
        return major;
    }

    public void setMajor(String major) {
        this.major = major;
    }

    public String getMinor() {
        return minor;
    }

    public void setMinor(String minor) {
        this.minor = minor;
    }

    public String getBirth_date() {
        return birth_date;
    }

    public void setBirth_date(String birth_date) {
        this.birth_date = birth_date;
    }

    public String getDate_became_christian() {
        return date_became_christian;
    }

    public void setDate_became_christian(String date_became_christian) {
        this.date_became_christian = date_became_christian;
    }

    public String getGraduation_date() {
        return graduation_date;
    }

    public void setGraduation_date(String graduation_date) {
        this.graduation_date = graduation_date;
    }

    public String getPicture() {
        return picture;
    }

    public void setPicture(String picture) {
        this.picture = picture;
    }

    public Long getUser_id() {
        return user_id;
    }

    public void setUser_id(Long user_id) {
        this.user_id = user_id;
    }

    public Long getFb_uid() {
        return fb_uid;
    }

    public void setFb_uid(Long fb_uid) {
        this.fb_uid = fb_uid;
    }

    public String getUpdated_at() {
        return updated_at;
    }

    public void setUpdated_at(String updated_at) {
        this.updated_at = updated_at;
    }

    public String getCreated_at() {
        return created_at;
    }

    public void setCreated_at(String created_at) {
        this.created_at = created_at;
    }

    /**
     * To-one relationship, resolved on first access.
     */
    public User getUser() {
        Long __key = this.user_id;
        if (user__resolvedKey == null || !user__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            UserDao targetDao = daoSession.getUserDao();
            User userNew = targetDao.load(__key);
            synchronized (this) {
                user = userNew;
                user__resolvedKey = __key;
            }
        }
        return user;
    }

    /**
     * To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity.
     */
    public List<Address> getAddressList() {
        if (addressList == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            AddressDao targetDao = daoSession.getAddressDao();
            List<Address> addressListNew = targetDao._queryPerson_AddressList(id);
            synchronized (this) {
                if (addressList == null) {
                    addressList = addressListNew;
                }
            }
        }
        return addressList;
    }

    /**
     * Resets a to-many relationship, making the next get call to query for a fresh result.
     */
    public synchronized void resetAddressList() {
        addressList = null;
    }

    /**
     * To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity.
     */
    public List<EmailAddress> getEmailAddressList() {
        if (emailAddressList == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            EmailAddressDao targetDao = daoSession.getEmailAddressDao();
            List<EmailAddress> emailAddressListNew = targetDao._queryPerson_EmailAddressList(id);
            synchronized (this) {
                if (emailAddressList == null) {
                    emailAddressList = emailAddressListNew;
                }
            }
        }
        return emailAddressList;
    }

    /**
     * Resets a to-many relationship, making the next get call to query for a fresh result.
     */
    public synchronized void resetEmailAddressList() {
        emailAddressList = null;
    }

    /**
     * To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity.
     */
    public List<PhoneNumber> getPhoneNumberList() {
        if (phoneNumberList == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            PhoneNumberDao targetDao = daoSession.getPhoneNumberDao();
            List<PhoneNumber> phoneNumberListNew = targetDao._queryPerson_PhoneNumberList(id);
            synchronized (this) {
                if (phoneNumberList == null) {
                    phoneNumberList = phoneNumberListNew;
                }
            }
        }
        return phoneNumberList;
    }

    /**
     * Resets a to-many relationship, making the next get call to query for a fresh result.
     */
    public synchronized void resetPhoneNumberList() {
        phoneNumberList = null;
    }

    /**
     * To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity.
     */
    public List<OrganizationalLabel> getOrganizationalLabelList() {
        if (organizationalLabelList == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            OrganizationalLabelDao targetDao = daoSession.getOrganizationalLabelDao();
            List<OrganizationalLabel> organizationalLabelListNew = targetDao._queryPerson_OrganizationalLabelList(id);
            synchronized (this) {
                if (organizationalLabelList == null) {
                    organizationalLabelList = organizationalLabelListNew;
                }
            }
        }
        return organizationalLabelList;
    }

    /**
     * Resets a to-many relationship, making the next get call to query for a fresh result.
     */
    public synchronized void resetOrganizationalLabelList() {
        organizationalLabelList = null;
    }

    /**
     * To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity.
     */
    public List<OrganizationalPermission> getOrganizationalPermissionList() {
        if (organizationalPermissionList == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            OrganizationalPermissionDao targetDao = daoSession.getOrganizationalPermissionDao();
            List<OrganizationalPermission> organizationalPermissionListNew = targetDao._queryPerson_OrganizationalPermissionList(id);
            synchronized (this) {
                if (organizationalPermissionList == null) {
                    organizationalPermissionList = organizationalPermissionListNew;
                }
            }
        }
        return organizationalPermissionList;
    }

    /**
     * Resets a to-many relationship, making the next get call to query for a fresh result.
     */
    public synchronized void resetOrganizationalPermissionList() {
        organizationalPermissionList = null;
    }

    /**
     * To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity.
     */
    public List<ContactAssignment> getAssigned_to() {
        if (assigned_to == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            ContactAssignmentDao targetDao = daoSession.getContactAssignmentDao();
            List<ContactAssignment> assigned_toNew = targetDao._queryPerson_Assigned_to(id);
            synchronized (this) {
                if (assigned_to == null) {
                    assigned_to = assigned_toNew;
                }
            }
        }
        return assigned_to;
    }

    /**
     * Resets a to-many relationship, making the next get call to query for a fresh result.
     */
    public synchronized void resetAssigned_to() {
        assigned_to = null;
    }

    /**
     * To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity.
     */
    public List<ContactAssignment> getAssigned_to_me() {
        if (assigned_to_me == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            ContactAssignmentDao targetDao = daoSession.getContactAssignmentDao();
            List<ContactAssignment> assigned_to_meNew = targetDao._queryPerson_Assigned_to_me(id);
            synchronized (this) {
                if (assigned_to_me == null) {
                    assigned_to_me = assigned_to_meNew;
                }
            }
        }
        return assigned_to_me;
    }

    /**
     * Resets a to-many relationship, making the next get call to query for a fresh result.
     */
    public synchronized void resetAssigned_to_me() {
        assigned_to_me = null;
    }

    /**
     * To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity.
     */
    public List<Interaction> getReceivedInteractions() {
        if (receivedInteractions == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            InteractionDao targetDao = daoSession.getInteractionDao();
            List<Interaction> receivedInteractionsNew = targetDao._queryPerson_ReceivedInteractions(id);
            synchronized (this) {
                if (receivedInteractions == null) {
                    receivedInteractions = receivedInteractionsNew;
                }
            }
        }
        return receivedInteractions;
    }

    /**
     * Resets a to-many relationship, making the next get call to query for a fresh result.
     */
    public synchronized void resetReceivedInteractions() {
        receivedInteractions = null;
    }

    /**
     * To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity.
     */
    public List<Interaction> getCreatedInteractions() {
        if (createdInteractions == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            InteractionDao targetDao = daoSession.getInteractionDao();
            List<Interaction> createdInteractionsNew = targetDao._queryPerson_CreatedInteractions(id);
            synchronized (this) {
                if (createdInteractions == null) {
                    createdInteractions = createdInteractionsNew;
                }
            }
        }
        return createdInteractions;
    }

    /**
     * Resets a to-many relationship, making the next get call to query for a fresh result.
     */
    public synchronized void resetCreatedInteractions() {
        createdInteractions = null;
    }

    /**
     * To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity.
     */
    public List<Interaction> getUpdatedInteractions() {
        if (updatedInteractions == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            InteractionDao targetDao = daoSession.getInteractionDao();
            List<Interaction> updatedInteractionsNew = targetDao._queryPerson_UpdatedInteractions(id);
            synchronized (this) {
                if (updatedInteractions == null) {
                    updatedInteractions = updatedInteractionsNew;
                }
            }
        }
        return updatedInteractions;
    }

    /**
     * Resets a to-many relationship, making the next get call to query for a fresh result.
     */
    public synchronized void resetUpdatedInteractions() {
        updatedInteractions = null;
    }

    /**
     * To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity.
     */
    public List<InteractionInitiator> getInteractionInitiatorList() {
        if (interactionInitiatorList == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            InteractionInitiatorDao targetDao = daoSession.getInteractionInitiatorDao();
            List<InteractionInitiator> interactionInitiatorListNew = targetDao._queryPerson_InteractionInitiatorList(id);
            synchronized (this) {
                if (interactionInitiatorList == null) {
                    interactionInitiatorList = interactionInitiatorListNew;
                }
            }
        }
        return interactionInitiatorList;
    }

    /**
     * Resets a to-many relationship, making the next get call to query for a fresh result.
     */
    public synchronized void resetInteractionInitiatorList() {
        interactionInitiatorList = null;
    }

    /**
     * To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity.
     */
    public List<AnswerSheet> getAnswerSheetList() {
        if (answerSheetList == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            AnswerSheetDao targetDao = daoSession.getAnswerSheetDao();
            List<AnswerSheet> answerSheetListNew = targetDao._queryPerson_AnswerSheetList(id);
            synchronized (this) {
                if (answerSheetList == null) {
                    answerSheetList = answerSheetListNew;
                }
            }
        }
        return answerSheetList;
    }

    /**
     * Resets a to-many relationship, making the next get call to query for a fresh result.
     */
    public synchronized void resetAnswerSheetList() {
        answerSheetList = null;
    }

    /**
     * Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context.
     */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }
        myDao.delete(this);
    }

    /**
     * Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context.
     */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }
        myDao.update(this);
    }

    /**
     * Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context.
     */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }
        myDao.refresh(this);
    }

    // KEEP METHODS - put your custom methods here
    public SetMultimap<Long, Long> getLabels() {
        if (mLabels == null) {
            synchronized (this) {
                final SetMultimap<Long, Long> labelsTemp = Multimaps.synchronizedSetMultimap(HashMultimap.<Long, Long>create());
                resetOrganizationalLabelList();
                try {
                    final List<OrganizationalLabel> labels = getOrganizationalLabelList();
                    for (final OrganizationalLabel label : labels) {
                        label.refresh();
                        labelsTemp.put(label.getOrganization_id(), label.getLabel_id());
                    }
                } catch (final DaoException e) {
                    getLabels();
                }
                mLabels = labelsTemp;
            }
        }
        return mLabels;
    }

    public List<Long> getLables(long organizationId) {
        return new ArrayList<Long>(getLabels().get(organizationId));
    }

    public synchronized void resetLabels() {
        mLabels = null;
    }

    public boolean hasLabel(final long organizationId, final long... labelIds) {
        boolean has = false;
        for (final long id : labelIds) {
            if (getLabels().containsEntry(organizationId, id)) {
                has = true;
            }
        }
        return has;
    }

    public Map<Long, Long> getBasicPermissions() {
        if (mPermissions == null) {
            synchronized (this) {
                resetOrganizationalPermissionList();

                final Map<Long, Long> temp = Collections.synchronizedMap(new HashMap<Long, Long>());
                final List<OrganizationalPermission> permissions = getOrganizationalPermissionList();

                for (OrganizationalPermission permission : permissions) {
                    permission.refresh();
                    temp.put(permission.getOrganization_id(), permission.getPermission_id());
                }
                mPermissions = temp;
            }
        }
        return mPermissions;
    }

    public boolean hasBasicPermission(long permissionId, long organizationId) {
        final Long perm = getBasicPermissions().get(organizationId);
        if (perm != null && perm.longValue() == permissionId) {
            return true;
        }
        return false;
    }

    public boolean hasPermission(long permissionId) {
        return hasPermission(permissionId, Session.getInstance().getOrganizationId());
    }

    public long getPermission(long organizationId) {
        if (daoSession == null) {
            throw new DaoException("Entity is detached from DAO context");
        }

        if (mPermissionCache == null) {
            synchronized (this) {
                mPermissionCache = Multimaps.synchronizedSetMultimap(HashMultimap.<Long, PermissionEntry>create());
            }
        }

        final Set<PermissionEntry> cached = mPermissionCache.get(organizationId);
        for (PermissionEntry entry : cached) {
            if (entry.getValue()) {
                return entry.getKey();
            }
        }

        OrganizationalPermission permission = daoSession.getOrganizationalPermissionDao().queryBuilder().where(OrganizationalPermissionDao.Properties.Person_id.eq(getId()), OrganizationalPermissionDao.Properties.Organization_id.eq(organizationId)).unique();
        if (permission != null) {
            synchronized (this) {
                mPermissionCache.put(organizationId, new PermissionEntry(permission.getPermission_id(), true));
            }
            return permission.getPermission_id();
        }

        // check sub orgs
        Organization organization = daoSession.getOrganizationDao().load(organizationId);
        if (organization != null && StringUtils.isNotEmpty(organization.getAncestry())) {
            // find the parent with a permission
            List<String> ancestors = Arrays.asList(organization.getAncestry().trim().split("/"));
            Collections.reverse(ancestors);
            for (String ancestor : ancestors) {
                permission = daoSession.getOrganizationalPermissionDao().queryBuilder().where(OrganizationalPermissionDao.Properties.Person_id.eq(getId()), OrganizationalPermissionDao.Properties.Organization_id.eq(Long.parseLong(ancestor))).unique();
                if (permission != null) {
                    Organization parent = Application.getDb().getOrganizationDao().load(Long.parseLong(ancestor));
                    if (parent != null && parent.getShow_sub_orgs()) {
                        synchronized (this) {
                            mPermissionCache.put(organizationId, new PermissionEntry(permission.getPermission_id(), true));
                            return permission.getPermission_id();
                        }
                    } else if (parent != null && !parent.getShow_sub_orgs()) {
                        break;
                    }
                }
            }
        }
        return Permission.NO_PERMISSIONS;
    }

    public boolean hasPermission(long permissionId, long organizationId) {
        if (daoSession == null) {
            throw new DaoException("Entity is detached from DAO context");
        }

        if (mPermissionCache == null) {
            synchronized (this) {
                mPermissionCache = Multimaps.synchronizedSetMultimap(HashMultimap.<Long, PermissionEntry>create());
            }
        }

        final Set<PermissionEntry> cached = mPermissionCache.get(organizationId);
        for (PermissionEntry entry : cached) {
            if (entry.getKey() == permissionId) {
                return entry.getValue();
            }
        }

        if (hasBasicPermission(permissionId, organizationId)) {
            synchronized (this) {
                mPermissionCache.put(organizationId, new PermissionEntry(permissionId, true));
            }
            return true;
        }

        // check sub orgs for admins and leaders
        if (permissionId == Permission.ADMIN || permissionId == Permission.USER) {
            Organization organization = daoSession.getOrganizationDao().load(organizationId);
            if (organization != null && StringUtils.isNotEmpty(organization.getAncestry())) {

                // find the parent with a permission
                List<String> ancestors = Arrays.asList(organization.getAncestry().trim().split("/"));
                Collections.reverse(ancestors);
                Organization parent = null;
                for (String ancestor : ancestors) {
                    if (hasBasicPermission(permissionId, Long.parseLong(ancestor))) {
                        parent = Application.getDb().getOrganizationDao().load(Long.parseLong(ancestor));
                        break;
                    }
                }
                synchronized (this) {
                    if (parent != null && parent.getShow_sub_orgs()) {
                        mPermissionCache.put(organizationId, new PermissionEntry(permissionId, true));
                        return true;
                    } else {
                        mPermissionCache.put(organizationId, new PermissionEntry(permissionId, false));
                        return false;
                    }
                }
            }
        }

        return false;
    }

    public synchronized void resetPermissionCache() {
        mPermissionCache = null;
    }

    public boolean isAdminOrUser() {
        return isAdminOrUser(Session.getInstance().getOrganizationId());
    }

    public boolean isAdminOrUser(final long organizationId) {
        return isAdmin(organizationId) || isUser(organizationId);
    }

    public boolean isAdmin() {
        return isAdmin(Session.getInstance().getOrganizationId());
    }

    public boolean isUser() {
        return isUser(Session.getInstance().getOrganizationId());
    }

    public void setUser(User user) {
        synchronized (this) {
            this.user = user;
            user_id = user == null ? null : user.getId();
            user__resolvedKey = user_id;
        }
    }

    public boolean isAdmin(final long organizationId) {
        return hasPermission(Permission.ADMIN, organizationId);
    }

    public boolean isUser(final long organizationId) {
        return hasPermission(Permission.USER, organizationId);
    }

    /**
     * Returns the person's primary organization id
     *
     * @return
     */
    public Long getPrimaryOrganizationId() {
        if (getUser() != null) {
            return getUser().getPrimary_organization_id();
        }
        return -1l;
    }

    public Organization getPrimaryOrganization() {
        if (daoSession == null) {
            throw new DaoException("Entity is detached from DAO context");
        }
        final OrganizationDao targetDao = daoSession.getOrganizationDao();
        return targetDao.load(getPrimaryOrganizationId());
    }

    public synchronized void resetOrganizationHierarchy() {
        mOrganizationHierarchy = null;
    }

    /**
     * Returns a tree of the user's privileged organizations
     *
     * @return
     */
    public TreeDataStructure<Long> getOrganizationHierarchy() {
        if (mOrganizationHierarchy == null) {
            synchronized (this) {
                if (daoSession == null) {
                    throw new DaoException("Entity is detached from DAO context");
                }

                // build a tree from organization ancestry
                final TreeDataStructure<Long> tree = new TreeDataStructure<Long>(0l);

                final List<Organization> organizations = Application.getDb()
                        .getOrganizationDao()
                        .queryBuilder()
                        .where(new WhereCondition.StringCondition(OrganizationDao.Properties.Id.columnName + " IN " + "(SELECT " + OrganizationalPermissionDao.TABLENAME + "."
                                + OrganizationalPermissionDao.Properties.Organization_id.columnName + " FROM " + OrganizationalPermissionDao.TABLENAME + " WHERE " + OrganizationalPermissionDao.TABLENAME + "."
                                + OrganizationalPermissionDao.Properties.Person_id.columnName + " = " + getId() + " AND " + OrganizationalPermissionDao.TABLENAME + "."
                                + OrganizationalPermissionDao.Properties.Permission_id.columnName + " IN (" + Permission.ADMIN + "," + Permission.USER + ")" + ")")).orderAsc(OrganizationDao.Properties.Name).build()
                        .list();

                for (final Organization organization : organizations) {
                    recursiveBuildOrganizationHierarchy(tree, organization);
                }

                mOrganizationHierarchy = tree;
            }
        }
        return mOrganizationHierarchy;
    }

    private void recursiveBuildOrganizationHierarchy(final TreeDataStructure<Long> tree, final Organization organization) {
        if (organization.getAncestry() != null) {
            TreeDataStructure<Long> parent = tree;
            boolean hasPermissions = false;
            for (final String ancestor : organization.getAncestry().trim().split("/")) {
                final Long a = Long.parseLong(ancestor);
                if (isAdminOrUser(a)) {
                    hasPermissions = true;
                }
                if (hasPermissions) {
                    if (parent.getTree(a) == null) {
                        parent = parent.addLeaf(a);
                    } else {
                        parent = parent.getTree(a);
                    }
                }
            }
            if (parent.getTree(organization.getId()) == null) {
                parent.addLeaf(organization.getId());
            }
        } else {
            if (tree.getTree(organization.getId()) == null) {
                if (isAdminOrUser(organization.getId())) {
                    tree.addLeaf(organization.getId());
                }
            }
        }

        // parse sub orgs
        if (organization.getShow_sub_orgs()) {
            final List<Organization> subOrgs = organization.getSubOrganizations();
            for (final Organization subOrg : subOrgs) {
                recursiveBuildOrganizationHierarchy(tree, subOrg);
            }
        }
    }

    /**
     * @return the person's full first and last name
     */
    public synchronized String getName() {
        String name = "";
        if (StringUtils.isNotEmpty(getFirst_name())) {
            name += getFirst_name();
        }
        if (StringUtils.isNotEmpty(getLast_name())) {
            name += (" " + getLast_name());
        }
        return name.trim();
    }

    public synchronized Address getCurrentAddress() {
        for (final Address address : getAddressList()) {
            return address;
        }
        return null;
    }

    public synchronized void deleteWithRelations() {
        if (daoSession == null) {
            throw new DaoException("Entity is detached from DAO context");
        }

        daoSession.getContactAssignmentDao().deleteByKeyInTx(daoSession.getContactAssignmentDao().queryBuilder().whereOr(ContactAssignmentDao.Properties.Assigned_to_id.eq(id), ContactAssignmentDao.Properties.Person_id.eq(id)).<Long>listKeys());
        daoSession.getAddressDao().deleteByKeyInTx(daoSession.getAddressDao().queryBuilder().where(AddressDao.Properties.Person_id.eq(id)).<Long>listKeys());
        daoSession.getEmailAddressDao().deleteByKeyInTx(daoSession.getEmailAddressDao().queryBuilder().where(EmailAddressDao.Properties.Person_id.eq(id)).<Long>listKeys());
        daoSession.getInteractionDao().deleteByKeyInTx(daoSession.getInteractionDao().queryBuilder().where(InteractionDao.Properties.Receiver_id.eq(id)).<Long>listKeys());
        daoSession.getOrganizationalPermissionDao().deleteByKeyInTx(daoSession.getOrganizationalPermissionDao().queryBuilder().where(OrganizationalPermissionDao.Properties.Person_id.eq(id)).<Long>listKeys());
        daoSession.getOrganizationalLabelDao().deleteByKeyInTx(daoSession.getOrganizationalLabelDao().queryBuilder().where(OrganizationalLabelDao.Properties.Person_id.eq(id)).<Long>listKeys());
        daoSession.getPhoneNumberDao().deleteByKeyInTx(daoSession.getPhoneNumberDao().queryBuilder().where(PhoneNumberDao.Properties.Person_id.eq(id)).<Long>listKeys());
        daoSession.getUserDao().deleteByKeyInTx(daoSession.getUserDao().queryBuilder().where(UserDao.Properties.Person_id.eq(id)).<Long>listKeys());

        delete();
    }

    public synchronized GPerson getGModel() {
        final GPerson p = new GPerson();

        p.id = getId();
        p.first_name = getFirst_name();
        p.last_name = getLast_name();
        p.gender = getGender();

        final List<GEmailAddress> emails = new ArrayList<GEmailAddress>();
        final List<EmailAddress> addresses = getEmailAddressList();
        for (final EmailAddress address : addresses) {
            emails.add(GEmailAddress.createFromEmailAddress(address));
        }
        p.email_addresses = emails.toArray(new GEmailAddress[emails.size()]);

        final List<GPhoneNumber> numbers = new ArrayList<GPhoneNumber>();
        final List<PhoneNumber> phones = getPhoneNumberList();
        for (final PhoneNumber number : phones) {
            numbers.add(GPhoneNumber.createFromPhoneNumber(number));
        }
        p.phone_numbers = numbers.toArray(new GPhoneNumber[numbers.size()]);

        final List<GAddress> gAddrs = new ArrayList<GAddress>();
        final List<Address> addrs = getAddressList();
        for (final Address address : addrs) {
            gAddrs.add(GAddress.createFromAddress(address));
        }
        p.addresses = gAddrs.toArray(new GAddress[gAddrs.size()]);

        return p;
    }

    public synchronized void resetStatus() {
        mStatuses = null;
    }

    public synchronized FollowupStatus getStatus() {
        return getStatus(Session.getInstance().getOrganizationId());
    }

    public synchronized FollowupStatus getStatus(final long organizationId) {
        if (mStatuses == null) {
            mStatuses = new HashMap<Long, FollowupStatus>();
        }

        if (mStatuses.get(organizationId) == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }

            OrganizationalPermission permission = daoSession.getOrganizationalPermissionDao().queryBuilder().where(OrganizationalPermissionDao.Properties.Organization_id.eq(organizationId),
                    OrganizationalPermissionDao.Properties.Person_id.eq(id)).limit(1).unique();

            if (permission != null) {
                mStatuses.put(organizationId, FollowupStatus.parse(permission.getFollowup_status()));
            }
        }
        return mStatuses.get(organizationId);
    }

    public synchronized PhoneNumber getPrimaryPhoneNumber() {
        if (mPrimaryPhoneNumber != null) return mPrimaryPhoneNumber;

        if (daoSession == null) {
            throw new DaoException("Entity is detached from DAO context");
        }

        mPrimaryPhoneNumber = daoSession.getPhoneNumberDao().queryBuilder().where(PhoneNumberDao.Properties.Person_id.eq(getId()), PhoneNumberDao.Properties.Primary.eq(true)).limit(1).unique();
        return mPrimaryPhoneNumber;
    }

    public synchronized void resetPrimaryPhoneNumber() {
        mPrimaryPhoneNumber = null;
    }

    public synchronized EmailAddress getPrimaryEmailAddress() {
        if (mPrimaryEmailAddress != null) return mPrimaryEmailAddress;

        if (daoSession == null) {
            throw new DaoException("Entity is detached from DAO context");
        }

        mPrimaryEmailAddress = daoSession.getEmailAddressDao().queryBuilder().where(EmailAddressDao.Properties.Person_id.eq(getId()), EmailAddressDao.Properties.Primary.eq(true)).limit(1).unique();
        return mPrimaryEmailAddress;
    }

    public synchronized void resetPrimaryEmailAddress() {
        mPrimaryEmailAddress = null;
    }

    public synchronized ContactAssignment getContactAssignment() {
        return getContactAssignment(Session.getInstance().getOrganizationId());
    }

    public synchronized ContactAssignment getContactAssignment(final long organizationId) {
        if (mContactAssignments == null) {
            mContactAssignments = new HashMap<Long, ContactAssignment>();
        }

        if (mContactAssignments.get(organizationId) == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            mContactAssignments.put(
                    organizationId,
                    Application.getDb().getContactAssignmentDao().queryBuilder()
                            .where(ContactAssignmentDao.Properties.Person_id.eq(getId()), ContactAssignmentDao.Properties.Organization_id.eq(Session.getInstance().getOrganizationId()))
                            .orderDesc(ContactAssignmentDao.Properties.Updated_at).limit(1).unique());
        }
        return mContactAssignments.get(organizationId);
    }

    public synchronized void resetContactAssignments() {
        mContactAssignments = null;
    }

    public synchronized Gender getGenderEnum() {
        if (StringUtils.isEmpty(getGender())) {
            return null;
        }
        try {
            return Gender.valueOf(getGender());
        } catch (final Exception e) {
            return null;
        }
    }

    public synchronized void refreshAll() {
        refresh();
        resetStatus();
        resetPrimaryEmailAddress();
        resetPrimaryPhoneNumber();
        resetContactAssignments();
        invalidateViewCache();
    }

    public PersonViewCache getViewCache() {
        if (mPersonViewCache == null) {
            mPersonViewCache = new PersonViewCache();
            mPersonViewCache.name = getName();
            if (getGenderEnum() != null) {
                mPersonViewCache.gender = getGenderEnum().toString();
            }
            if (getStatus() != null) {
                mPersonViewCache.status = getStatus().toString();
            }
            if (getPrimaryEmailAddress() != null) {
                mPersonViewCache.email = getPrimaryEmailAddress().getEmail();
                mPersonViewCache.emailClickListener = new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        IntentHelper.sendEmail(getPrimaryEmailAddress().getEmail(), null, null);
                    }
                };
            }
            final Phonenumber.PhoneNumber number = PhoneUtils.parsePhoneNumber(getPrimaryPhoneNumber());
            if (number != null) {
                if (PhoneNumberUtil.getInstance().isPossibleNumber(number)) {
                    mPersonViewCache.phone = PhoneNumberUtil.getInstance().format(number, PhoneNumberUtil.PhoneNumberFormat.INTERNATIONAL);
                    mPersonViewCache.phoneClickListener = new View.OnClickListener() {
                        @Override
                        public void onClick(View view) {
                            IntentHelper.dialNumber(number);
                        }
                    };
                }
            }
            Permission permission = Application.getDb().getPermissionDao().load(getPermission(Session.getInstance().getOrganizationId()));
            if (permission != null) {
                mPersonViewCache.permission = permission.getTranslatedName();
            }
        }

        return mPersonViewCache;
    }

    public void invalidateViewCache() {
        mPersonViewCache = null;
    }

    public String getPictureUrl(int width, int height) {
        if (getPicture() == null || getPicture().contains("facebook.com") || getPicture().contains("fbcdn.net")) {
            if (getFb_uid() != null && getFb_uid() > 0) {
                return "http://graph.facebook.com/" + getFb_uid() + "/picture?width=" + width + "&height=" + height;
            }
        }
        return getPicture();
    }

    public static class PermissionEntry extends SimpleEntry<Long, Boolean> {
        public PermissionEntry(Long role, Boolean permission) {
            super(role, permission);
        }
    }

    public static class PersonViewCache {
        public String name;
        public String gender;
        public String status;
        public String email;
        public View.OnClickListener emailClickListener;
        public String phone;
        public View.OnClickListener phoneClickListener;
        public String permission;
    }
    // KEEP METHODS END

}
